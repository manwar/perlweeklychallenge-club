#!perl

###############################################################################
=comment

Perl Weekly Challenge 150
=========================

TASK #1
-------
*Fibonacci Words*

Submitted by: Mohammad S Anwar

You are given two strings having same number of digits, $a and $b.

Write a script to generate Fibonacci Words by concatenation of the previous two
strings. Finally print 51st digit of the first term having at least 51 digits.

Example:

    Input: $a = '1234' $b = '5678'
    Output: 7

    Fibonacci Words:

    '1234'
    '5678'
    '12345678'
    '567812345678'
    '12345678567812345678'
    '56781234567812345678567812345678'
    '1234567856781234567856781234567812345678567812345678'

    The 51st digit in the first term having at least 51 digits
    '1234567856781234567856781234567812345678567812345678' is 7.

=cut
###############################################################################

#--------------------------------------#
# Copyright Â© 2022 PerlMonk Athanasius #
#--------------------------------------#

#==============================================================================
=comment

Algorithm
---------
As with the standard Fibonacci sequence, each term is generated by combining
the two immediately-preceding terms. In this case, "combining" is done by con-
catenation rather than addition.

Extensions
----------
I have extended the Task in two ways:

(1) An explanation of the answer is provided in the form given in the Example.
    The required digit is highlighted in-place in the final Fibonacci word by a
    caret symbol directly below. (The explanation may be suppressed by setting
    the constant $VERBOSE to a false value.)

(2) The constant $TARGET may be set to any integer value greater than 1, and
    the output will still be correct.

=cut
#==============================================================================

use strict;
use warnings;
use Const::Fast;

use constant VERBOSE => 1;

const my $TARGET => 51;
const my $USAGE  =>
"Usage:
  perl $0 <a> <b>

    <a>    A string of digits
    <b>    Another string of digits of the same length\n";

#------------------------------------------------------------------------------
BEGIN
#------------------------------------------------------------------------------
{
    $| = 1;
    print "\nChallenge 150, Task #1: Fibonacci Words (Perl)\n\n";
}

#==============================================================================
MAIN:
#==============================================================================
{
    my ($A, $B) = parse_command_line();

    print "Input:  \$a = '$A' \$b = '$B'\n";

    my  $length = length $A;
    my ($x, $y) = ($A, $B);
    my  @words  = ($A, $B)           if VERBOSE;

    while ($length < $TARGET)
    {
        my $z = $x . $y;
           $x = $y;
           $y = $z;

        $length = length $y;

        push @words, $y              if VERBOSE;
    }

    my $fib   = $TARGET > length $A ? $y : $A;
    my $digit = substr $fib, $TARGET - 1, 1;

    print "Output: $digit\n";

    explain( $fib, $digit, \@words ) if VERBOSE;
}

if (VERBOSE)
{
    #--------------------------------------------------------------------------
    sub explain
    #--------------------------------------------------------------------------
    {
        my ($fib, $digit, $words) = @_;

        print  "\nFibonacci Words:\n\n";

        print  "'$_'\n" for @$words;

        printf "\nThe %s digit in the first term having at least %d digits\n",
                ordinal( $TARGET ), $TARGET;

        printf "'%s' is %d\n%s^\n", $fib, $digit, ' ' x $TARGET;
    }

    #--------------------------------------------------------------------------
    sub ordinal
    #--------------------------------------------------------------------------
    {
        my ($num) = @_;
        my  $suff = 'th';
        my  $dig1 = int( ($num % 100) / 10 );          # Tens digit

        if ($dig1 != 1)
        {
            my $dig0 = $num % 10;                      # Ones digit

            $suff = $dig0 == 1 ? 'st' :
                    $dig0 == 2 ? 'nd' :
                    $dig0 == 3 ? 'rd' : 'th';
        }

        return $num . $suff;
    }
}

#------------------------------------------------------------------------------
sub parse_command_line
#------------------------------------------------------------------------------
{
    my $args = scalar @ARGV;
       $args == 2 or error( "Expected 2 command line arguments, found $args" );

    / ^ \d+ $ /x  or error( qq["$_" contains a non-digit] ) for @ARGV;

    length $ARGV[ 0 ] == length $ARGV[ 1 ]
                  or error( 'The strings are different lengths' );

    return @ARGV;
}

#------------------------------------------------------------------------------
sub error
#------------------------------------------------------------------------------
{
    my ($message) = @_;

    die "ERROR: $message\n$USAGE";
}

###############################################################################
