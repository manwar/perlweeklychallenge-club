#!perl

###############################################################################
=comment

Perl Weekly Challenge 096
=========================

Task #2
-------
*Edit Distance*

Submitted by: Mohammad S Anwar

You are given two strings $S1 and $S2.

Write a script to find out the minimum operations required to convert $S1 into
$S2. The operations can be insert, remove or replace a character. Please check
out [https://en.wikipedia.org/wiki/Edit_distance |Wikipedia] page for more in-
formation.

Example 1:

 Input: $S1 = "kitten"; $S2 = "sitting"
 Output: 3

 Operation 1: replace 'k' with 's'
 Operation 2: replace 'e' with 'i'
 Operation 3: insert 'g' at the end

Example 2:

 Input: $S1 = "sunday"; $S2 = "monday"
 Output: 2

 Operation 1: replace 's' with 'm'
 Operation 2: replace 'u' with 'o'

=cut
###############################################################################

#--------------------------------------#
# Copyright Â© 2021 PerlMonk Athanasius #
#--------------------------------------#

#==============================================================================
=comment

Since the allowable operations are given as "insert, remove or replace a
character", we may assume that the edit distance required in this Task is the
Levenshtein distance.

A single insert, remove, or replace operation is assigned a cost of one. To
determine the minimum overall cost, the dynamic-programming Wagner-Fischer
algorithm is used. A Matrix class is provided to facilitate implementation of
the algorithm.

The Wagner-Fischer algorithm is not the fastest, but it does create a full
matrix which can then be used to reconstruct the changes by which the first
string has been transformed into the second. If the $EXPLAIN constant below is
set to a true value, the minimum operations required to transform $S1 into $S2
are listed in the output below the Levenshtein distance. If both $EXPLAIN and
$SHOW_MATRIX are set to true values, the matrix generated by the Wagner-Fischer
algorithm is also displayed.

=cut
#==============================================================================

use strict;
use warnings;
use Const::Fast;
use lib qw( . );
use Matrix;

const my $EXPLAIN     => 1;
const my $SHOW_MATRIX => 0;
const my $USAGE       =>
"Usage:
  perl $0 <S1> <S2>

    <S1>    First string
    <S2>    Second string\n";

#------------------------------------------------------------------------------
BEGIN
#------------------------------------------------------------------------------
{
    $| = 1;
    print "\nChallenge 096, Task #2: Edit Distance (Perl)\n\n";
}

#==============================================================================
MAIN:
#==============================================================================
{
    my ($S1, $S2) = parse_command_line();

    printf qq[Input:  \$S1 = "%s"; \$S2 = "%s"\n], $S1, $S2;

    my ($distance, $matrix) = levenshtein_distance($S1, $S2);

    printf qq[Output: %d (Levenshtein distance)\n], $distance;

    if ($EXPLAIN)
    {
        print "\n", $matrix->display if $SHOW_MATRIX;

        my $path = trace_path($matrix);
        my $ops  = find_operations($path, $S1, $S2);

        print "\n$ops" if $ops;
    }
}

#------------------------------------------------------------------------------
sub levenshtein_distance
#------------------------------------------------------------------------------
{
    my ($s, $t) = @_;
    my  $matrix = Matrix->new($s, $t);
    my  @s      = ('#', split //, $s);
    my  @t      = ('#', split //, $t);

    for my $row (1 .. $#t)
    {
        for my $col (1 .. $#s)
        {
            my $del_cost = $matrix->element($row - 1, $col    ) + 1;
            my $ins_cost = $matrix->element($row,     $col - 1) + 1;
            my $sub_cost = $matrix->element($row - 1, $col - 1) +
                               (($t[ $row ] eq $s[ $col ]) ? 0  : 1);

            $matrix->element($row, $col, min($del_cost, $ins_cost, $sub_cost));
        }
    }

    return ($matrix->element($#t, $#s), $matrix);
}

#------------------------------------------------------------------------------
sub trace_path
#------------------------------------------------------------------------------
{
    my ($matrix) = @_;
    my  $row     = $matrix->height - 1;
    my  $col     = $matrix->width  - 1;
    my  $min     = $matrix->element($row, $col);
    my  @path    = [ $row, $col, $min ];

    until ($row == 0 && $col == 0)
    {
        if    ($col == 0)
        {
            $min = $matrix->element(--$row,   $col);        # Move up:   insert
        }
        elsif ($row == 0)
        {
            $min = $matrix->element(  $row, --$col);        # Move left: delete
        }
        else
        {
            my $up   = $matrix->element($row - 1, $col    );
            my $left = $matrix->element($row,     $col - 1);
            my $diag = $matrix->element($row - 1, $col - 1);

            if    ($diag <= $up   && $diag <= $left)
            {                                               # Move up and left:
                $min = $matrix->element(--$row, --$col);    #           replace
            }
            elsif ($up   <= $diag && $up   <= $left)
            {
                $min = $matrix->element(--$row,   $col);    # Move up:   insert
            }
            else
            {
                $min = $matrix->element(  $row, --$col);    # Move left: delete
            }
        }

        push @path, [ $row, $col, $min ];
    }

    return [ reverse @path ];
}

#------------------------------------------------------------------------------
sub find_operations
#------------------------------------------------------------------------------
{
    my ($path, $s, $t) = @_;
    my  $summary       = '';
    my  $last          = shift @$path;
    my  $count         = 0;

    while (my $next = shift @$path)
    {
        if ($next->[2] > $last->[2])
        {
            my  $op;

            if    ($next->[0] == $last->[0])
            {
                $op = sprintf "remove '%s'",
                               substr($s, $next->[1] - 1, 1);
            }
            elsif ($next->[1] == $last->[1])
            {
                $op = sprintf "insert '%s'",
                               substr($t, $next->[0] - 1, 1);
            }
            else
            {
                $op = sprintf "replace '%s' with '%s'",
                               substr($s, $next->[1] - 1, 1),
                               substr($t, $next->[0] - 1, 1);
            }

            $summary .= sprintf "Operation %d: %s\n", ++$count, $op;
        }

        $last = $next;
    }

    return $summary;
}

#------------------------------------------------------------------------------
sub min
#------------------------------------------------------------------------------
{
    my ($x, $y, $z) = @_;

    my  $min = $x;
        $min = $y if $y < $min;
        $min = $z if $z < $min;

    return $min;
}

#------------------------------------------------------------------------------
sub parse_command_line
#------------------------------------------------------------------------------
{
    my $args = scalar @ARGV;

    if    ($args < 2)
    {
        die "ERROR: Too few command-line arguments\n$USAGE";
    }
    elsif ($args > 2)
    {
        die "ERROR: Too many command-line arguments\n$USAGE";
    }

    return @ARGV[ 0 .. 1 ];
}

###############################################################################
