%!PS

% begin included library code
% see https://codeberg.org/Firedrake/postscript-libraries/
/test.end {
    ( ) print
    test.count 0 gt {
        (Passed ) print
        test.pass (...) cvs print
        (/) print
        test.count (...) cvs print
        ( \() print
        test.pass 100 mul test.count idiv (...) cvs print
        (%\)) print
        (\r\n) print
    } if
} bind def

/tolower {
    s2a
    [ exch
      {
          dup dup 65 ge exch 90 le and {
              32 add
          } if
      } forall
    ] a2s
} bind def

/quicksort.main { % lo hi -> (null)
    3 dict begin
    /hi exch def
    /lo exch def
    /xit false def
    lo 0 lt {
        /xit true def
    } if
    hi 0 lt {
        /xit true def
    } if
    lo hi ge {
        /xit true def
    } if
    xit not {
        /p quicksort.partition def
        lo p quicksort.main
        p 1 add hi quicksort.main
    } if
    end
} bind def

/quicksort.swap {
    2 dict begin
    /bi exch def
    /ai exch def
    arr ai get
    arr bi get
    arr exch ai exch put
    arr exch bi exch put
    end
} bind def

/quicksort.with_comparator { % [ a c b ] { comparator } -> [ a b c ]
    2 dict begin
    /cmp exch def
    /arr exch def
    arr length 0 gt {
        0 arr length 1 sub quicksort.main
    } if
    arr
    end
} bind def

/quicksort.partition {
    3 dict begin
    /pivot arr hi lo add 2 idiv get def
    /i lo 1 sub def
    /j hi 1 add def
    {
        {
            /i i 1 add def
            arr i get pivot cmp 0 ge {
                exit
            } if
        } loop
        {
            /j j 1 sub def
            arr j get pivot cmp 0 le {
                exit
            } if
        } loop
        i j ge {
            j
            exit
        } if
        i j quicksort.swap
    } loop
    end
} bind def

/a2s {
    2 dict begin
    /i exch def
    i length dup string /o exch def
    1 sub 0 exch 1 exch {
        dup i 3 -1 roll get o 3 1 roll put
    } for
    o
    end
} bind def


/strjoin % [(a) (b) (c)] (j) -> (ajbjc)
{
    3 dict begin
    /j exch def
    dup 0 get /out exch def
    /first true def
    {
        first {
            pop
            /first false def
        } {
            out j strconcat
            exch strconcat
            /out exch def
        } ifelse
    } forall
    out
    end
} bind def

/quicksort.with_keygen { % [ a c b ] { keygen } -> [ a b c ]
    3 dict begin
    /kg exch def
    /arr exch def
    /kl << arr {
                dup kg
            } forall >> def
    arr {
        exch kl exch get exch kl exch get quicksort.cmp
    } quicksort.with_comparator
} bind def

/strconcat % (a) (b) -> (ab)  
{
    [
        3 -1 roll
        s2a aload length
        2 add -1 roll
        s2a aload pop
    ] a2s
} bind def

/test {
    /test.count test.count 1 add def
    {
        /test.pass test.pass 1 add def
    } {
        ( ) print
        test.count (....) cvs print
        (-fail) print
    } ifelse
    count /test.stack2 exch def
    test.stack test.stack2 ne {
        print
        (Warning: stack deviation ) print
        test.stack2 test.stack sub print
        (\r\n) print
    } if
} bind def

/quicksort.cmp {
    2 copy
    lt {
        pop pop -1
    } {
        gt {
            1
        } {
            0
        } ifelse
    } ifelse
} bind def

/strsplit % (ajbjc) (j) -> [ (a) (b) (c) ]
{
    1 dict begin
    /sep exch def
    [ exch
      {
          dup length 0 eq {
              pop
              exit
          } {
              sep search {
                  exch pop
                  dup length 0 eq {
                      pop
                  } {
                      exch
                  } ifelse
              } {
                  ()
              } ifelse
          } ifelse
      } loop
    ]
    end
} bind def

/test.start {
    print (:) print
    /test.pass 0 def
    /test.count 0 def
    count /test.stack exch def
} bind def

/s2a {
    [ exch { } forall ]
} bind def



% end included library code

/wordsorter {
    ( ) strsplit
    { tolower } quicksort.with_keygen
    ( ) strjoin
} bind def

(wordsorter) test.start
(The quick brown fox) wordsorter (brown fox quick The) eq test
(Hello    World!   How   are you?) wordsorter (are Hello How World! you?) eq test
(Hello) wordsorter (Hello) eq test
(Hello, World! How are you?) wordsorter (are Hello, How World! you?) eq test
(I have 2 apples and 3 bananas!) wordsorter (2 3 and apples bananas! have I) eq test
test.end
